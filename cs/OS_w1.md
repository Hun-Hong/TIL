# 프로세스와 스레드 학습 자료

## 📚 기초 이론 (Fundamental Concepts)

### 1. 프로그램 vs 프로세스 vs 스레드
- **프로그램(Program)**: 저장장치에 저장되어 있는 정적인 코드 (실행 파일)
- **프로세스(Process)**: 실행 중인 프로그램. 메모리에 적재되어 CPU를 할당받을 수 있는 상태
- **스레드(Thread)**: 프로세스 내에서 실행되는 흐름의 단위

### 2. 프로세스 메모리 구조
프로세스는 메모리에서 다음과 같은 영역을 가집니다:
- **코드(Text) 영역**: 프로그램의 실행 코드가 저장
- **데이터(Data) 영역**: 전역 변수, 정적 변수가 저장
- **힙(Heap) 영역**: 동적으로 할당되는 메모리 (malloc, new 등)
- **스택(Stack) 영역**: 함수 호출시 생성되는 지역 변수, 매개변수 저장

### 3. 프로세스 상태(Process State)
```
[New] → [Ready] ⇄ [Running] → [Terminated]
            ↓         ↓
         [Waiting/Blocked]
```

**상태 전이 조건**:
- **New → Ready**: 프로세스 생성 완료, Ready Queue에 삽입
- **Ready → Running**: 스케줄러가 CPU 할당 (Dispatch)
- **Running → Ready**: 할당된 시간 만료 (Time Quantum 초과)
- **Running → Waiting**: I/O 요청 또는 이벤트 대기
- **Waiting → Ready**: I/O 완료 또는 이벤트 발생
- **Running → Terminated**: 프로세스 실행 완료

### 4. Process Control Block (PCB)
운영체제가 각 프로세스를 관리하기 위해 유지하는 자료구조:

**PCB 구성 요소**:
- **프로세스 식별자**: PID (Process ID), PPID (Parent PID)
- **프로세스 상태**: New, Ready, Running, Waiting, Terminated
- **프로그램 카운터(PC)**: 다음에 실행할 명령어의 주소
- **CPU 레지스터**: 모든 범용 레지스터의 값
- **CPU 스케줄링 정보**: 우선순위, 스케줄링 큐 포인터
- **메모리 관리 정보**: 페이지 테이블, 세그먼트 테이블
- **회계 정보**: CPU 사용 시간, 실제 사용 시간
- **I/O 상태 정보**: 할당된 I/O 장치들과 열린 파일 목록

### 5. 문맥교환(Context Switch)
**정의**: CPU가 한 프로세스에서 다른 프로세스로 실행 권한을 넘기는 과정

**문맥교환 과정**:
1. 현재 실행 중인 프로세스의 상태를 PCB에 저장
2. 다음 실행할 프로세스의 PCB에서 상태 정보를 복원
3. CPU 레지스터에 새로운 프로세스의 값들을 적재
4. 새로운 프로세스 실행 시작

**문맥교환이 발생하는 경우**:
- 할당된 시간 만료 (Time Quantum)
- I/O 요청
- 높은 우선순위 프로세스 도착
- 시스템 콜 호출

**문맥교환 오버헤드**:
- PCB 저장/복원 시간
- 캐시 메모리 무효화 (Cache Miss 증가)
- TLB(Translation Lookaside Buffer) 무효화

### 6. 프로세스 스케줄링 큐
**Ready Queue**: CPU를 기다리는 프로세스들의 큐
- 우선순위에 따라 정렬되어 있을 수 있음
- FIFO, Priority Queue, Multi-level Queue 등 다양한 구조

**Device Queue (Wait Queue)**: 특정 자원을 기다리는 프로세스들의 큐
- 각 I/O 장치마다 별도의 큐 존재
- 디스크 큐, 프린터 큐, 네트워크 큐 등

**Job Queue**: 시스템의 모든 프로세스들의 큐

### 7. 스케줄러(Scheduler) 종류
**장기 스케줄러(Long-term Scheduler)**:
- Job Queue에서 Ready Queue로 프로세스 선택
- 다중 프로그래밍의 정도(degree of multiprogramming) 결정
- 실행 빈도가 낮음 (초 단위)

**단기 스케줄러(Short-term Scheduler)**:
- Ready Queue에서 실행할 프로세스 선택
- 가장 빈번하게 실행 (밀리초 단위)
- CPU 스케줄러라고도 함

**중기 스케줄러(Medium-term Scheduler)**:
- 메모리에서 프로세스를 제거하여 다중 프로그래밍 정도 조절
- Swapping 담당 (Swap out/in)

### 8. 동기식 I/O vs 비동기식 I/O
**동기식(Synchronous) I/O**:
- I/O 요청 후 완료될 때까지 프로세스가 대기
- 프로세스가 블록(Block) 상태가 됨
- 구현이 간단하지만 CPU 효율성 떨어짐

**비동기식(Asynchronous) I/O**:
- I/O 요청 후 즉시 다른 작업 수행 가능
- I/O 완료 시 인터럽트나 콜백으로 알림
- CPU 효율성 높지만 구현 복잡

### 9. 스레드(Thread) 기본 개념
**정의**: 프로세스 내에서 실행되는 여러 흐름의 단위

**스레드의 구성**:
- **독립적 영역**: Stack, PC(Program Counter), Register
- **공유 영역**: Code, Data, Heap, 파일 등 OS 자원

**스레드 vs 프로세스 메모리 구조**:
```
프로세스 A        프로세스 B
┌─────────┐      ┌─────────┐
│  Stack  │      │  Stack  │
├─────────┤      ├─────────┤
│  Heap   │      │  Heap   │
├─────────┤      ├─────────┤
│  Data   │      │  Data   │
├─────────┤      ├─────────┤
│  Code   │      │  Code   │
└─────────┘      └─────────┘

멀티스레드 프로세스
┌─────────┐
│Stack T1 │Stack T2│ (각 스레드별 Stack)
├─────────┤─────────
│      Heap       │ (공유)
├─────────────────┤
│      Data       │ (공유)
├─────────────────┤
│      Code       │ (공유)
└─────────────────┘
```

### 10. 멀티프로세스 vs 멀티스레드
**멀티프로세스**:
- 여러 개의 독립된 프로세스가 동시에 실행
- 각 프로세스는 독립된 메모리 공간
- 프로세스 간 통신은 IPC(Inter-Process Communication) 필요
- 안정성 높음 (한 프로세스 오류가 다른 프로세스에 영향 X)
- 메모리 사용량 많음, 생성/전환 비용 높음

**멀티스레드**:
- 하나의 프로세스 내에서 여러 스레드가 동시에 실행
- 메모리 공간 공유 (Code, Data, Heap)
- 스레드 간 통신이 간단함 (공유 메모리 사용)
- 메모리 사용량 적음, 생성/전환 비용 낮음
- 안정성 낮음 (한 스레드 오류가 전체 프로세스에 영향)

### 11. 스레드 구현 방식
**사용자 레벨 스레드(User-Level Thread)**:
- 운영체제가 스레드의 존재를 모름
- 스레드 라이브러리가 스레드 관리
- 장점: 빠른 생성/전환, 운영체제 독립적
- 단점: 한 스레드가 블록되면 전체 프로세스 블록, 멀티프로세서 활용 불가

**커널 레벨 스레드(Kernel-Level Thread)**:
- 운영체제가 스레드를 직접 관리
- 각 스레드마다 PCB 생성
- 장점: 멀티프로세서에서 병렬 실행 가능, 한 스레드 블록시 다른 스레드 계속 실행
- 단점: 생성/전환 비용 높음, 시스템 콜 오버헤드


## 문제 풀이

### 문제 1

다음 중 프로세스 상태 전이에 대한 설명으로 **틀린** 것은?

A) New → Ready: 프로세스가 생성되어 Ready Queue에 삽입
B) Ready → Running: 스케줄러에 의해 CPU를 할당받음
C) Running → Waiting: I/O 요청 또는 이벤트 대기
D) Waiting → Running: I/O 완료 후 바로 CPU 할당
E) Running → Ready: 할당된 시간이 만료됨

답안: D
Waiting 에서 Running으로 바로 이동하는 것은 불가능
대기하던 프로세스가 I/O 요청이 끝나면 다시 Ready Queue에 삽입
되어 CPU할당을 기다려야 함
올바른 상태 전이 : Waiting -> Ready

### 문제 2

다음 빈칸을 채우시오.

"CPU가 한 프로세스에서 다른 프로세스로 넘어가는 과정을 **(A)**라고 하며, 이때 현재 프로세스의 상태 정보는 **(B)**에 저장된다. 이 과정에서 발생하는 시간적 비용을 **(C)**라고 한다."

답안:
(A): Context Switch (문맥 교환)
(B): PCB(Process Control Block)
(C): 오버헤드?

### 문제 3

다음 조건을 만족하는 멀티스레드 웹 서버를 설계하고자 합니다.

**조건**:

- 동시 처리 가능한 최대 클라이언트: 1000명
- 평균 요청 처리 시간: 100ms
- 메모리 사용량 최소화
- CPU 사용률 최대화

위 조건을 만족하기 위한 스레드 풀 설계 방안을 제시하고, 사용자 레벨 스레드와 커널 레벨 스레드 중 어떤 것을 선택할지 근거와 함께 설명하시오. 또한 예상되는 문제점과 해결 방안을 제시하시오.

답안:
사용자 레벨 스레드 vs 커널 레벨 스레드

사용자 레벨 스레드
 - 운영체제가 스레드가 있는지 모름
 - 멀티 프로세싱 불가능 => CPU 사용률 최대화 불가능
  => 평균 요청 처리 시간의 경우 커널 레벨 스레드에 비해
  오버헤드가 적어 유리할 수 있음
  => 멀티 프로세싱이 불가능하기 때문에 동시 처리 부분에서
  에러가 발생할 수 있음

커널 레벨 스레드
  - 커널이 스레드를 관리하고 스레드 별 PCB 생성
  - 시스템 오버헤드가 있음
  => 멀티 프로세싱으로 CPU를 최대한 활용할 수 있음
  => 스레드 별 PCB로 메모리 사용량이 증가함
  => 시스템 오버헤드로 인해 요청 처리 시간 증가

해결방안)
  사실 잘 모르겠음. 설명도 제대로 한 건지 애매함.
  설명 부탁


### 문제 4 - 네이버 기술면접 기출

**프로세스와 스레드의 차이를 설명해보세요. 그리고 Context Switching 작업이 왜 오래 걸리는지 설명하세요.**

프로세스는 Code, Data, Stack 등 프로세스가 동작하는데 필요한 자원이 독립적으로 존재함

스레드는 Code, Data 등 공유 데이터와 각자 프로세스의 동작인 Stack만 독립적으로 존재함

프로세스 간의 Context Switching 작업에서 메모리에 저장된 PC를 레지스터에 복원해야하는데 메모리 접근 시간이 오래 걸림

스레드 끼리의 Context Swiching의 경우 모든 메모리를 공유하므로 Context Swiching을 하더라도 메모리를 복원하지 않아도 됨

### 문제 5 - 카카오 기술면접 기출

**멀티 스레드와 멀티 프로세스의 차이점을 설명하고, 각각의 장단점을 비교하여 설명해보세요. 또한 어떤 상황에서 멀티 스레드를 사용하고, 어떤 상황에서 멀티 프로세스를 사용하는 것이 적합한지 실제 예시와 함께 설명하세요.**

멀티 스레드 vs 멀티 프로세스

스레드 구조와 프로세스 구조의 차이점을 비교하는 내용이라고 생각함
스레드 구조는 공유 메모리 구조로 Context Swiching 속도가 빠르다는 장점이 있음. 하지만 한 스레드의 문제가 멀티 스레드 내의 모든 스레드로 전파된다는 문제가 있음.
반대로 프로세스 구조는 프로세스가 독립적으로 메모리를 관리하므로 안정성과 오류 전파 측면에서 강점이 있음. 하지만 Context Swiching시 메모리 접근에 의한 오버헤드에 의해 스레드 구조보다 느리다는 단점이 있음. 

## 🏆 모범 답안
### 문제 3 모범 답안
스레드 풀 설계:
1. 스레드 풀 크기: 200-300개
   - CPU 코어 수 × 2~3 (I/O 대기 시간 고려)
   - 1000명 동시 접속이지만 모두가 동시에 요청하지 않음

2. 작업 큐: Bounded Queue (크기 제한)
   - 메모리 사용량 제어
   - 과부하 시 요청 거부로 시스템 보호

3. 스레드 종류 선택: 커널 레벨 스레드
   - 이유: 멀티코어 CPU 활용 필수 (CPU 사용률 최대화)
   - I/O 블로킹 시 다른 스레드가 계속 실행 가능

예상 문제점과 해결방안:
문제: 스레드 간 경쟁 상태
해결: Thread-safe 자료구조 사용, 뮤텍스/세마포어 활용

### 상세 설명
멀티스레드 웹 서버 설계 상세 분석
1. 스레드 풀 크기 결정 (200-300개)
계산 근거:
기본 공식: 스레드 수 = CPU 코어 수 × (1 + 대기시간/처리시간)

예시 계산 (8코어 서버):
- 요청 처리 시간: 100ms
- I/O 대기 시간: 200ms (DB 조회, 파일 읽기 등)
- 스레드 수 = 8 × (1 + 200/100) = 8 × 3 = 24개

하지만 웹 서버는 더 많은 스레드가 필요:
- 네트워크 I/O 대기가 빈번함
- 실제로는 200-300개가 적절
왜 1000개가 아닌가?:

메모리 제약: 스레드당 스택 메모리 (보통 1-8MB)

1000개 × 2MB = 2GB (스택만으로!)

컨텍스트 스위칭 오버헤드: 너무 많으면 성능 저하
실제 동시 처리: 1000명이 동시에 요청하지 않음

2. Bounded Queue (작업 큐) 설계
큐 크기 제한의 이유:
- 메모리 보호: 무제한 큐는 메모리 부족 야기
- 응답성 보장: 큐가 가득 차면 즉시 거부 (빠른 실패)
- 시스템 안정성: 과부하 시 전체 시스템 다운 방지

3. 커널 레벨 스레드 선택 이유
멀티코어 활용:
사용자 레벨 스레드:
CPU Core 1: [T1, T2, T3] ← 모든 스레드가 하나 코어에만
CPU Core 2: [   비어있음   ]
CPU Core 3: [   비어있음   ]
CPU Core 4: [   비어있음   ]
→ CPU 사용률: 25%

커널 레벨 스레드:
CPU Core 1: [T1, T5]
CPU Core 2: [T2, T6] 
CPU Core 3: [T3, T7]
CPU Core 4: [T4, T8]
→ CPU 사용률: 100%

### 문제 4 모범 답안
Context Switching이 오래 걸리는 이유:

PCB 저장/복원: 레지스터, PC 등을 메모리에 저장/복원
캐시 무효화: 이전 프로세스 데이터가 캐시에서 사라져 캐시 미스 발생
TLB 플러시: 주소 변환 테이블 무효화로 메모리 접근 지연
파이프라인 플러시: CPU 명령어 파이프라인 재시작

### 문제 5 모범 답안
사용 시나리오:
멀티스레드가 적합한 경우:
웹 서버: 빠른 응답, 메모리 효율성 중요
게임 서버: 실시간 처리, 공유 상태 관리
GUI 애플리케이션: UI 스레드와 작업 스레드 분리

멀티프로세스가 적합한 경우:
웹 브라우저: 탭별 독립성, 하나 탭 오류가 전체에 영향 X
데이터베이스: 트랜잭션 격리, 안정성 중요
분산 시스템: 노드별 독립 실행